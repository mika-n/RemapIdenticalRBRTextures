using System;
using System.IO;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Runtime.InteropServices;
using System.IO.Compression;
//using System.Diagnostics;
//using System.Reflection.Metadata;

namespace RemapIdenticalRBRTextures
{
    class DeduplicateFiles
    {
        //-----------------------------------------------------------------------------------------------------------------------
        // Remove identical textures
        //
        public static int RemoveIdenticalTextures(string rbrFolder, string backupFolder, List<int> trackIDList, bool deleteDuplicatedFiles, bool forceUpdate)
        {
            string[] allSkyTypes = { "M", "N", "E", "O" };

            string trackIDDesc = string.Empty;
            string trackIDStr = string.Empty;

            string trackName;
            string trackFolder;
            string sourceFile;

            string tempTextureFilenameMapFile;

            SortedDictionary<string, string> textureRemapList = new SortedDictionary<string, string>(); // Name=Value pair of remapping (value=remap source, key=remap target)

            int dupNumOfFiles;

            // Lookup the TrackName INI option from Tracks.ini file. M/N/E/O_textures.rbz files are in the trackName folder
            INIFile tracksINIFile = new INIFile(Path.Combine(@rbrFolder, "Maps\\Tracks.ini"));

            // List of trackIDs as a string
            foreach (int trackID in trackIDList)
            {
                if (!string.IsNullOrEmpty(trackIDStr))
                {
                    trackIDStr += "_";
                    trackIDDesc += " - ";
                }

                // "320_321_322" trackID string identifier (used in temporary folder and filenames)
                trackIDStr += trackID.ToString();

                // "320-Slovkia Ring 2014 - 321-Slovakia Ring 2014 II" description label in TextureFilenameMap1234.ini file
                trackName = tracksINIFile.ReadValue($"Map{trackID}", "TrackName");
                if (!string.IsNullOrEmpty(trackName))
                {
                    trackName = Path.GetFileName(Path.GetDirectoryName(trackName));
                }

                if (string.IsNullOrEmpty(trackName))
                {
                    trackIDDesc += trackID.ToString();
                }
                else
                {
                    trackIDDesc += trackName;
                }
            }

            backupFolder = Path.Combine(backupFolder + "\\", $"{DateTime.Now.ToString("yyyyMMdd_HHmmss")}_{trackIDStr}");

            // Temporary folder location for RBZ extraction and a temporary texture INI mapfile
            string tempZipFolder = Path.Combine(backupFolder + "\\", "rbz");

            //
            // Extract all RBZ files into a temp folder from all tracks specifeid in -track cmdline option (one or more)
            //
            foreach (int trackID in trackIDList)
            {
                trackName = tracksINIFile.ReadValue($"Map{trackID}", "TrackName");

                if (!string.IsNullOrEmpty(trackName))
                {
                    trackFolder = Path.GetDirectoryName(Path.Combine(@rbrFolder, trackName));

                    // Extract all textures.rbz files to a temp folder
                    Directory.CreateDirectory(tempZipFolder);
                    foreach (string skyType in allSkyTypes)
                    {
                        sourceFile = Path.Combine(@rbrFolder, trackName + "_" + skyType + "_textures.rbz");
                        if (File.Exists(sourceFile))
                        {
                            Console.WriteLine($"Unziping {sourceFile} to {tempZipFolder}");
                            ZipFile.ExtractToDirectory(sourceFile, tempZipFolder + "\\", true);
                        }
                    }
                }
            }

            //
            // Check duplicates in RBZ temp folder (there are DDS files from one or more xxx.rbz RBR texture archives)
            //
            dupNumOfFiles = RSFCheckDuplicatedFiles(tempZipFolder, textureRemapList);
            Console.WriteLine($"{dupNumOfFiles} DDS texture duplicates found");

            if (dupNumOfFiles > 0)
            {
                tempTextureFilenameMapFile = $"{backupFolder}\\TextureFilenameMap_{trackIDStr}.ini";

                // Write the new TextureFilenameMap.ini file at first in temp folder before copying the file to RBR maps folder
                using (StreamWriter sw = new StreamWriter(tempTextureFilenameMapFile))
                {
                    sw.WriteLine($"; {DateTime.Now.ToString("yyyyMMdd_HHmmss")} - {trackIDDesc} - Autogenerated remap file by RallySimFans RemapIdenticalRBRTextures tool");
                    sw.WriteLine("; TAB char is the separator (originalFile remapTargetFile)");

                    foreach (var item in textureRemapList)
                    {
                        sw.WriteLine($"{item.Key.ToLower()}\t{item.Value.ToLower()}");
                    }
                }

                // Copy new RBZ texture archives to trackFolder
                foreach (int trackID in trackIDList)
                {
                    trackName = tracksINIFile.ReadValue($"Map{trackID}", "TrackName");
                    if (!string.IsNullOrEmpty(trackName))
                    {
                        trackFolder = Path.GetDirectoryName(Path.Combine(@rbrFolder, trackName));
                        RepackTexturesAndCopyToRBRMapsFolder(tempZipFolder, tempTextureFilenameMapFile, backupFolder, trackID, trackFolder, deleteDuplicatedFiles, forceUpdate);
                    }
                }
            }

            if (Directory.Exists(tempZipFolder))
                Directory.Delete(tempZipFolder, true);

            return 0;
        }


        //-------------------------------------------------------------------
        // Check if there are identical texture files within RBR textures.rbz file. Create TextureFilenameMapXXX.ini remap file and optionally delete duplicated files in the RBZ archive to save diskspace.
        // Return number of duplicated files found or 0 if no duplicates</returns>
        //
        private static int RSFCheckDuplicatedFiles(/*string rbrFolder, string trackFolder,*/ string tempZipFolder, SortedDictionary<string, string> textureRemapList /*, bool deleteDuplicatedFiles */)
        {
            int numOfTotalFiles;
            int numOfDuplicateFiles = 0;

            SortedDictionary<string, RBZFileInfo> fileList = new SortedDictionary<string, RBZFileInfo>();
            Dictionary<string, RBZFileInfo> sameSizeList = new Dictionary<string, RBZFileInfo>();

            Console.WriteLine($"Checking duplicates");

            // Recursively iterate all files from top to bottom folder (filename+filesize)
            DirectoryInfo dir = new DirectoryInfo(tempZipFolder);
            numOfTotalFiles = GetFilesRecursively(dir, "", fileList);

            Console.WriteLine($"{numOfTotalFiles} DDS texture files");

            //
            // Check all files for duplicates. Remove duplicates and add a new TextureFilenameMap.ini remapping entry
            // - Get the original fileName+fileInfo
            // - Find all files with the same size (skip the original fileName)
            // - Compare the file content between the original and all files with the same size (fileName doesn't have to be the same)
            // - Add duplicate files as TextureFilenameMap.ini remap lines and leave just the first (original) file
            //
            foreach (var origItem in fileList)
            {
                if (!origItem.Value.Processed)
                {
                    //Console.WriteLine($"{origItem.Key} = {origItem.Value.FileSize}");
                    origItem.Value.Processed = true;

                    // Find all files with the same filesize.
                    // A file with the same size is not automatically assumed to be identical, but we do know files with difference size for sure are not identical and so we can skip those right away.
                    sameSizeList.Clear();
                    foreach (var dupItem in fileList)
                    {
                        if (!dupItem.Value.Processed && dupItem.Value.FileSize == origItem.Value.FileSize)
                            sameSizeList.Add(dupItem.Key, dupItem.Value);
                    }

                    //Console.WriteLine($"{origItem.Key} has {sameSizeList.Count} potentially duplicated files. FileSize {origItem.Value.FileSize}");

                    // Compare origItem and all other files with the same size and remove duplicated identical files and add a new TextureFilenameMap.ini line
                    foreach (var sameSizeItem in sameSizeList)
                    {
                        if (origItem.Value.IsFileIdentical(sameSizeItem.Value))
                        {
                            //Console.WriteLine($"{sameSizeItem.Key} = {origItem.Key}");

                            sameSizeItem.Value.Processed = true;
                            sameSizeItem.Value.ReleaseContentBuffers();

                            // Delete duplicate copy and add a remap definition to the original identical file
                            File.Delete(sameSizeItem.Value.FileFullName);
                            textureRemapList.Add(sameSizeItem.Key, GetTextureRemapFileNameTarget(origItem.Key, sameSizeItem.Key));

                            numOfDuplicateFiles++;
                        }
                    }

                    origItem.Value.ReleaseContentBuffers();
                }
            }

            return numOfDuplicateFiles;
        }


        //-------------------------------------------------------------------
        // Repack textures and copy back to RBR Maps folder
        //
        private static void RepackTexturesAndCopyToRBRMapsFolder(string tempZipFolder, string tempTextureFilenameMapFile, string backupFolder, int trackID, string trackFolder, bool deleteDuplicatedFiles, bool forceUpdate)
        {
            int idx = 0;

            FileInfo sourceRBZFileInfo;
            FileInfo tmpZipFileFileInfo;
            string rbzOrigFileName;
            string rbzArchiveFileName;
            string tempZipFile;

            double newTotalSize = 0;
            double oldTotalSize = 0;

            DirectoryInfo[] dirs = (new DirectoryInfo(tempZipFolder)).GetDirectories($"track-{trackID}_*");

            foreach (var rbzDir in dirs)
            {
                // Texture folders should have a syntax or track-123_M_textures.rbz. The path prefix is the name of the RBZ archive file
                rbzArchiveFileName = rbzDir.Name + ".rbz";
                tempZipFile = Path.Combine(backupFolder + "\\", "new_" + rbzArchiveFileName);

                if (Path.GetExtension(rbzArchiveFileName) == ".rbz")
                {
                    idx++;
                    Console.WriteLine($"Ziping {idx}/{dirs.Length} rbz {rbzArchiveFileName}");

                    // TODO: 7zip tool if it makes smaller zip files?
                    ZipFile.CreateFromDirectory(rbzDir.FullName, tempZipFile, CompressionLevel.SmallestSize, true);
                }
            }

            // Backup the original RBZ archive file if the new RBZ is smaller than the original one
            idx = 0;
            foreach (var rbzDir in dirs)
            {
                idx++;
                rbzArchiveFileName = rbzDir.Name + ".rbz";
                tempZipFile = Path.Combine(backupFolder + "\\", "new_" + rbzArchiveFileName);
                if (Path.GetExtension(rbzArchiveFileName) == ".rbz")
                {
                    rbzOrigFileName = Path.Combine(trackFolder + "\\", rbzArchiveFileName);

                    sourceRBZFileInfo = new FileInfo(rbzOrigFileName);
                    tmpZipFileFileInfo = new FileInfo(tempZipFile);
                    if (sourceRBZFileInfo.Length > tmpZipFileFileInfo.Length)
                    {
                        double newSizeMB = tmpZipFileFileInfo.Length / (1024.0 * 1024.0);
                        double oldSizeMB = sourceRBZFileInfo.Length / (1024.0 * 1024.0);

                        newTotalSize += tmpZipFileFileInfo.Length;
                        oldTotalSize += sourceRBZFileInfo.Length;

                        if (deleteDuplicatedFiles)
                        {
                            Console.WriteLine($"Backuping {rbzOrigFileName} to {backupFolder}");
                            File.Copy(rbzOrigFileName, Path.Combine(backupFolder + "\\", rbzArchiveFileName));
                        }

                        Console.WriteLine($"{idx}/{dirs.Length} {rbzArchiveFileName} new size {newSizeMB.ToString("N2")} MB < {oldSizeMB.ToString("N2")} MB  (Saving {(oldSizeMB - newSizeMB).ToString("N2")} MBs)");
                    }
                    else
                    {
                        Console.WriteLine($"{idx}/{dirs.Length} {rbzArchiveFileName} would not save space. Keeping the original file");
                        File.Delete(tempZipFile);
                    }
                }
            }

            Console.WriteLine($"Total space saving {((oldTotalSize / (1024.0 * 1024.0)) - (newTotalSize / (1024.0 * 1024.0))).ToString("N2")} MBs");

            // Copy TextureFilenameMapXXX.ini file to trackFolder
            if (deleteDuplicatedFiles)
            {
                string textureMapFileNamePart = $"TextureFilenameMap{trackID}.ini"; // Path.GetFileName(tempTextureFilenameMapFile);
                string targetTextureMapFileName = Path.Combine(trackFolder + "\\", textureMapFileNamePart);

                if (forceUpdate == false && File.Exists(targetTextureMapFileName))
                {
                    // Hmmm... Existing TextureFilenameMapXXX.ini file. There may be conflicts if already repacked and remapped files are remapped again
                    Console.WriteLine($"ERROR. {targetTextureMapFileName} already exists. Use -ForceUpdate option to force update RBZ files");
                    return;
                }

                Console.WriteLine($"Copying {textureMapFileNamePart} to {trackFolder}");
                File.Copy(tempTextureFilenameMapFile, targetTextureMapFileName, true);
            }

            // Copy all new_*.rbz files back to RBR path to update rbz archive file with smaller rbz files
            foreach (var rbzDir in dirs)
            {
                rbzArchiveFileName = rbzDir.Name + ".rbz";
                tempZipFile = Path.Combine(backupFolder + "\\", "new_" + rbzArchiveFileName);
                if (File.Exists(tempZipFile) && Path.GetExtension(rbzArchiveFileName) == ".rbz")
                {
                    rbzOrigFileName = Path.Combine(trackFolder + "\\", rbzArchiveFileName);

                    if (deleteDuplicatedFiles)
                    {
                        Console.WriteLine($"Updating {rbzOrigFileName}");
                        File.Delete(rbzOrigFileName);
                        File.Copy(tempZipFile, Path.Combine(trackFolder + "\\", rbzOrigFileName));
                        File.Delete(tempZipFile);
                    }
                    else
                    {
                        Console.WriteLine($"DeleteDuplicates option NOT set. Skipping file update {rbzOrigFileName}");
                    }
                }
            }
        }


        // Remove RBZ archive fileName prefix from the target name AND the first texture path if it is the same as source name
        private static string GetTextureRemapFileNameTarget(string rbzTextureFileNameTarget, string rbzTextureFileNameSource)
        {
            int pathSepPosSource = rbzTextureFileNameSource.IndexOf('\\');
            int pathSepPosTarget = rbzTextureFileNameTarget.IndexOf('\\');
            if (pathSepPosSource > 0 && pathSepPosSource == pathSepPosTarget)
            {
                if (rbzTextureFileNameSource.Substring(0, pathSepPosSource) == rbzTextureFileNameTarget.Substring(0, pathSepPosTarget))
                    return rbzTextureFileNameTarget.Substring(pathSepPosTarget + 1);
            }

            return rbzTextureFileNameTarget;
        }


        //----------------------------------------------------------------------------------------------
        // Recursively collect file info from all files under dirInfo directory
        //
        private static int GetFilesRecursively(DirectoryInfo dir, string dirPath, SortedDictionary<string, RBZFileInfo> fileList)
        {
            int numOfFiles = 0;

            // Add files from the current dir
            FileInfo[] files = dir.GetFiles();
            foreach (var fileInfo in files)
            {
                if (string.Compare(fileInfo.Extension, ".dds", true) == 0)
                {
                    fileList.Add(dirPath + fileInfo.Name, new RBZFileInfo(fileInfo));
                    numOfFiles++;
                }
            }

            // Get all child directories and collect file infos recursively
            DirectoryInfo[] dirs = dir.GetDirectories();
            foreach (var childDir in dirs)
            {
                numOfFiles += GetFilesRecursively(childDir, dirPath + childDir.Name + "\\", fileList);
            }

            return numOfFiles;
        }

    }

}
